# 正規表現

## 正規表現
- ここでは, データ処理の強い味方｢正規表現｣を取り上げます.
    - 正規表現を使うことで, 文字列を自由自在に検出したり, 置き換えたりすることができます.
- 正規表現は非常に複雑なので(正規表現だけで分厚い1冊の技術書が書けるほどです), Perl入学式で全てを紹介することはできませんが, コードを書く上でよく使う｢基本的な部分｣を中心に, 紹介していきます.

## パターンマッチ
    my $str = 'papix loves perl!';
    if ($str =~ /perl/) {
        print "'$str'は'perl'を含みます.";
    }

- `$str =~ /perl/`は, `$str`の中に｢perl｣という文字列が含まれるなら真, そうでないなら(含まれないなら)偽, になります.
- この, `/`に囲まれた, 文字列のパターンを表現するものが｢正規表現｣です.

## パターンマッチ

    my $str = 'papix loves perl!';
    if ($str eq 'perl') {
        print "'$str'は'perl'です.";
    }
    if ($str =~ /perl/) {
        print "'$str'は'perl'を含みます.";
    }

- `eq`は完全一致か否かしか判定できません. しかし正規表現とパターンマッチを活用することで, ｢xxxという文字列を含む｣や, その逆の｢xxxという文字列を含まない｣といった複雑な判定を行うことができます.

## パターンマッチ
    my $str = 'papix loves perl!';
    if ($str !~ /ruby/) {
        print "'$str'は'ruby'を含みません.";
    }

- `$str !~ /ruby/`と書くことで, `$str`の中に｢ruby｣という文字列を含まないなら真, そうでないなら(含むなら)偽, になります.

## 任意の1文字
    my $ans = 'y';
    if($ans =~ /[yY]/) {
        print "文字列にはyないしYが含まれています.\n";
    }

- `[`と`]`で文字をくくると, []の中の任意の1文字にマッチします.
- よって`/[yY]/`は, `y`ないし`Y`にマッチします.

## 任意の1文字(否定)
    my $ans = 'n';
    if($ans =~ /[^yY]/) {
        print "文字列にはyないしY以外の文字が含まれています.\n";
    }

- `[`と`]`で文字をくくり, その先頭に`^`を置くと, []の中にない任意の1文字にマッチします.
- よって`/[^yY]/`は, `y`ないし`Y`以外の文字にマッチします.
- `^`は, 必ず`[`の後に置いて, `[^`の形で用います.

## 任意の1文字(連続)
    my $ans = 'b';
    if($ans =~ /[a-c]/) {
        print "文字列にはa, b, cのいずれかが含まれています.\n";
    }

- `[`と`]`の中で, 文字の間に`-`を挟むことによって, 文字列の範囲を表現できます.
- この場合, `[a-c]`は`[abc]`と同じ意味になります. `[1-5]`のように, 数値に対しても利用できます.

## ワイルドカード
    my $ans = 'get';
    if($ans =~ /g.t/) {
        print "マッチ!\n";
    }

- `.`は, 改行文字(`\n`)を除く, 任意の1文字にマッチします.
- よって`/g.t/`は, `get`や`got`など, `g+任意の1文字+t`にマッチします.
    * `.`がマッチするのは1文字だけなので, `goat`などはマッチしません.
    * また, `gt`にもマッチしません.

## 量指定子'?'
    my $ans = 'gt';
    if($ans =~ /g.?t/) {
        print "マッチ!\n";
    }

- `?`は, その直前の要素が0個または1個の場合にマッチします.
    * 例えば`ab?`は, `a`または`ab`にマッチします.
- よって`/g.?t/`は, `g+任意の1文字+t`に加え, `gt`にもマッチします.

## 量指定子'+'
    my $ans = 'get';
    if($ans =~ /g.+t/) {
        print "マッチ!\n";
    }

- `+`は, その直前の要素が1個以上の場合マッチします.
    * 例えば`ab+c`は, `abc`や`abbbbc`などにマッチしますが, `ac`にはマッチしません.
- よって, `/g.+t/`は, `g+任意の1文字以上+t`にマッチします.

## 量指定子'*'
    my $ans = 'great';
    if($ans =~ /g.*t/) {
        print "マッチ!\n";
    }

- `*`は, その直前の要素が0個以上の場合マッチします.
    * 例えば`ab*c`は, `ac`や`abc`, `abbbbbc`などにマッチします.
- よって`/g.*t/`は, `g`で始まり`t`で終わる全てのフレーズとマッチします(`great`など).

## 柔軟な量指定子
    my $str = 'Gyaaaaaaaaa!';
    print "マッチ!\n" if $str =~ /a{5,}/;
    # マッチする
    my $str2 = 'Gyaa!';
    print "マッチ!\n" if $str2 =~ /a{5,}/;
    # マッチしない

- `{m,n}` ... その直前の要素がm回以上, n回以下繰り返す場合マッチ
- `{m,}` ... その直前の要素がm回以上繰り返す場合マッチ
- `{m}` ... その直前の要素がm回繰り返す場合マッチ

## 練習問題

- 引数として文字列を受け取り, その文字列に`perl`ないし`Perl`が含まれるなら｢Perl Monger!｣と表示するサブルーチン`perl_checker`を書いてみましょう.
- コードは, `perl_checker.pl`という名前で保存するようにしましょう.

## マッチした文字列の取得
    my $str = '私は perl が好きです.';
    if($str =~ /私は (.+) が好き/) {
        print "彼は, $1 が好きです.\n";
        # => 彼は, perl が好きです
    }

- 正規表現のパターンを`()`を囲むと, そのパターンに一致する文字列を取得することができます.
- 例えばこの場合, $1には`perl`が入り, `彼は, perl が好きです.`と表示されるはずです.

## マッチした文字列の取得
    my $str = '私は perl と 旅行 が好きです.';
    if($str =~ /私は (.+) と (.+) が好き/) {
        print "彼は, $1 と $2 が好きです.\n";
        # => '彼は, perl と 旅行 が好きです.'と表示.
    }

- 複数の`()`が存在する場合, 先頭から`$1`, `$2`... で取得することができます.

## マッチングの原則
    my $str = 'Hello hoge! Hello fuga!';
    if($str =~ /Hello (.+)!/) {
        print "Nice to meet you, $1!\n";
    }

- `hoge`を抜き出して`Nice to meet you, hoge!`としたいので, このようなコードを書きました.
- しかしながら, 実際には`Nice to meet you, hoge! Hello fuga!`と表示されます.

## マッチングの原則
    my $str = 'Hello hoge! Hello fuga!';
    if($str =~ /Hello (.+?)!/) {
        print "Nice to meet you, $1!\n";
    }

- これは, 正規表現が｢なるべく長くマッチする(最長マッチ)｣ようになっている為です.
- このように, 量指定子のあとに`?`を付けて, 最短マッチにすれば, `Nice to meet you, hoge!`と出力されるはずです.

## 練習問題
    my $words_ref = [
        'papix loves meat!',
        'boolfool loves sushi!',
    ];

- このような配列のリファレンスを受け取り, リファレンスに格納された文字列について, ｢loves｣の後に記述されている好きな食べ物の単語を正規表現で取得し, ｢papix -> meat｣, ｢boolfool -> sushi｣のように表示するサブルーチン, `love_food`を書いてみよう.
- このコードは, `love_food.pl`という名前で保存するようにしましょう.
